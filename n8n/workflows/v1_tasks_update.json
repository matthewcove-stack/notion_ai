{
  "name": "v1_tasks_update",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "v1/notion/tasks/update",
        "responseMode": "responseNode"
      },
      "id": "3b274a8c-cb7c-4af7-bba5-3cbfa58b8915",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -200,
        0
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "\nconst executionId = this.getExecutionId ? this.getExecutionId() : Date.now().toString();\n\nfunction respond(statusCode, body) {\n  return [{ json: { httpStatus: statusCode, body } }];\n}\n\nfunction errorEnvelope(requestId, code, message, details) {\n  return {\n    request_id: requestId || null,\n    status: 'error',\n    correlation_id: executionId,\n    data: null,\n    error: { code, message, details: details || {} }\n  };\n}\n\nfunction okEnvelope(requestId, data) {\n  return {\n    request_id: requestId,\n    status: 'ok',\n    correlation_id: executionId,\n    data,\n    error: null\n  };\n}\n\nconst notionToken = $env.NOTION_API_KEY;\nif (!notionToken) {\n  return respond(500, errorEnvelope(null, 'config_error', 'NOTION_API_KEY is not set', {}));\n}\n\nconst baseUrl = 'https://api.notion.com/v1';\nconst notionHeaders = {\n  Authorization: `Bearer ${notionToken}`,\n  'Notion-Version': '2022-06-28',\n  'Content-Type': 'application/json'\n};\n\nconst request = async (method, urlPath, bodyData) => {\n  const options = {\n    method,\n    url: `${baseUrl}${urlPath}`,\n    headers: notionHeaders,\n    json: true\n  };\n  if (bodyData) options.body = bodyData;\n  return this.helpers.httpRequest(options);\n};\n\nconst titleText = (text) => ({ title: [{ text: { content: text } }] });\nconst richText = (text) => ({ rich_text: [{ text: { content: text } }] });\n\nconst getTitleFromPage = (page) => {\n  if (!page || !page.properties) return '';\n  const titleKey = Object.keys(page.properties).find((key) => page.properties[key].type === 'title');\n  if (!titleKey) return '';\n  const titleArray = page.properties[titleKey].title || [];\n  return titleArray.map((t) => t.plain_text).join('');\n};\n\nconst getTitleFromDatabase = (db) => {\n  if (!db || !Array.isArray(db.title)) return '';\n  return db.title.map((t) => t.plain_text).join('');\n};\n\nconst queryDatabase = async (dbId, filter) => {\n  return request('POST', `/databases/${dbId}/query`, { filter, page_size: 1 });\n};\n\nconst getPropertyText = (page, propName) => {\n  const prop = page.properties[propName];\n  if (!prop) return '';\n  if (prop.type === 'rich_text') return (prop.rich_text || []).map((t) => t.plain_text).join('');\n  if (prop.type === 'title') return (prop.title || []).map((t) => t.plain_text).join('');\n  return '';\n};\n\nconst findDatabaseByTitle = async (title) => {\n  const res = await request('POST', '/search', {\n    query: title,\n    page_size: 10,\n    filter: { property: 'object', value: 'database' }\n  });\n  return (res.results || []).find((db) => getTitleFromDatabase(db) === title) || null;\n};\n\nconst findRegistryDbId = async () => {\n  const registryDb = await findDatabaseByTitle('OS Registry');\n  return registryDb ? registryDb.id : null;\n};\n\nconst findRegistryValue = async (registryDbId, key) => {\n  const res = await queryDatabase(registryDbId, {\n    property: 'Key',\n    title: { equals: key }\n  });\n  const page = (res.results || [])[0];\n  if (!page) return null;\n  return getPropertyText(page, 'Value');\n};\n\nconst resolveLedgerDbId = async (registryDbId) => {\n  if (!registryDbId) return null;\n  const ledgerId = await findRegistryValue(registryDbId, 'ledger_db_id');\n  if (ledgerId) return ledgerId;\n  const ledgerDb = await findDatabaseByTitle('Request Ledger');\n  return ledgerDb ? ledgerDb.id : null;\n};\n\nconst resolveDatabaseId = async (registryDbId, databaseKey) => {\n  if (!registryDbId) return null;\n  if (databaseKey === 'registry') return registryDbId;\n  if (databaseKey === 'request_ledger') return await resolveLedgerDbId(registryDbId);\n  const key = `${databaseKey}_db_id`;\n  const dbId = await findRegistryValue(registryDbId, key);\n  return dbId || null;\n};\n\nconst findLedgerEntry = async (ledgerDbId, idempotencyKey) => {\n  const res = await queryDatabase(ledgerDbId, {\n    property: 'Idempotency Key',\n    title: { equals: idempotencyKey }\n  });\n  return (res.results || [])[0] || null;\n};\n\nconst createLedgerEntry = async (ledgerDbId, data) => {\n  const properties = {\n    'Idempotency Key': titleText(data.idempotencyKey),\n    'Request ID': richText(data.requestId),\n    'Endpoint': richText(data.endpoint),\n    'Status': { select: { name: data.status } },\n    'Result Object ID': richText(data.resultObjectId || ''),\n    'Timestamp': { date: { start: data.timestamp } },\n    'Raw Request': richText(data.rawRequest || '')\n  };\n  return request('POST', '/pages', {\n    parent: { database_id: ledgerDbId },\n    properties\n  });\n};\n\nconst getPage = async (pageId) => request('GET', `/pages/${pageId}`);\n\n\nconst headers = $json.headers || {};\nconst authHeader = (headers.authorization || headers.Authorization || '').trim();\nconst bearerToken = $env.BOOTSTRAP_BEARER_TOKEN || $env.API_BEARER_TOKEN || '';\n\nif (!bearerToken) {\n  return respond(500, errorEnvelope(null, 'config_error', 'No bearer token configured', {}));\n}\n\nconst expectedAuth = `Bearer ${bearerToken}`;\n\nif (authHeader !== expectedAuth) {\n  return respond(401, errorEnvelope(null, 'unauthorized', 'Invalid or missing Authorization header', {}));\n}\n\nconst body = $json.body;\nif (!body || typeof body !== 'object') {\n  return respond(400, errorEnvelope(null, 'invalid_request', 'Request body must be a JSON object', {}));\n}\n\nconst { request_id, idempotency_key, actor, payload } = body;\nif (typeof request_id !== 'string' || typeof idempotency_key !== 'string' || typeof actor !== 'string' || typeof payload !== 'object' || payload === null) {\n  return respond(400, errorEnvelope(request_id, 'invalid_request', 'Missing or invalid request envelope fields', {}));\n}\n\nconst { notion_page_id, patch } = payload;\nif (typeof notion_page_id !== 'string' || !notion_page_id.trim()) {\n  return respond(400, errorEnvelope(request_id, 'invalid_request', 'payload.notion_page_id is required', {}));\n}\n\nif (!patch || typeof patch !== 'object') {\n  return respond(400, errorEnvelope(request_id, 'invalid_request', 'payload.patch must be an object', {}));\n}\n\nconst hasPatch = ['status', 'due', 'priority', 'notes_append'].some((key) => Object.prototype.hasOwnProperty.call(patch, key));\nif (!hasPatch) {\n  return respond(400, errorEnvelope(request_id, 'invalid_request', 'patch must include at least one field', {}));\n}\n\ntry {\n  const registryDbId = await findRegistryDbId();\n  if (!registryDbId) {\n    return respond(500, errorEnvelope(request_id, 'registry_not_found', 'OS Registry database not found', {}));\n  }\n\n  const ledgerDbId = await resolveLedgerDbId(registryDbId);\n  if (!ledgerDbId) {\n    return respond(500, errorEnvelope(request_id, 'ledger_not_found', 'Request Ledger database not found', {}));\n  }\n\n  const existingLedger = await findLedgerEntry(ledgerDbId, idempotency_key);\n  if (existingLedger) {\n    const priorId = getPropertyText(existingLedger, 'Result Object ID') || notion_page_id;\n    const page = await getPage(priorId);\n    return respond(200, okEnvelope(request_id, {\n      updated: false,\n      notion_page_id: priorId,\n      notion_url: page.url\n    }));\n  }\n\n  let existingNotes = '';\n  if (patch.notes_append) {\n    const page = await getPage(notion_page_id);\n    existingNotes = getPropertyText(page, 'Notes');\n  }\n\n  const properties = {};\n  if (patch.status) {\n    properties.Status = { select: { name: patch.status } };\n  }\n  if (patch.due) {\n    properties.Due = { date: { start: patch.due } };\n  }\n  if (patch.priority) {\n    properties.Priority = { select: { name: patch.priority } };\n  }\n  if (patch.notes_append) {\n    const combined = existingNotes ? `${existingNotes}\\n${patch.notes_append}` : patch.notes_append;\n    properties.Notes = richText(combined);\n  }\n\n  const updated = await request('PATCH', `/pages/${notion_page_id}`, { properties });\n\n  const nowIso = new Date().toISOString();\n  await createLedgerEntry(ledgerDbId, {\n    idempotencyKey: idempotency_key,\n    requestId: request_id,\n    endpoint: '/v1/notion/tasks/update',\n    status: 'ok',\n    resultObjectId: notion_page_id,\n    timestamp: nowIso,\n    rawRequest: JSON.stringify(body)\n  });\n\n  return respond(200, okEnvelope(request_id, {\n    updated: true,\n    notion_page_id: updated.id,\n    notion_url: updated.url\n  }));\n} catch (error) {\n  const message = error && error.message ? error.message : 'Update task failed';\n  return respond(500, errorEnvelope(request_id, 'tasks_update_failed', message, { stack: error && error.stack }));\n}\n"
      },
      "id": "679d73b6-5b68-48ea-9d20-fbe41a3097a6",
      "name": "Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        40,
        0
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json.body}}",
        "options": {
          "responseCode": "={{$json.httpStatus}}"
        }
      },
      "id": "e82ad315-84ac-4ad4-b973-3623e1a05f3c",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        300,
        0
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handler": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "ac16fe17-34c2-477d-966c-99c816eb312e",
  "id": "bfa20919-1740-4b64-a028-224dc61c185b",
  "tags": []
}