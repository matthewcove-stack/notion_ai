{
  "name": "v1_db_sample",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "v1/notion/db/sample",
        "responseMode": "responseNode"
      },
      "id": "a71e0fdc-5278-4f52-8153-e9baec3033cb",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -200,
        0
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "\nconst executionId = this.getExecutionId ? this.getExecutionId() : Date.now().toString();\n\nfunction respond(statusCode, body) {\n  return [{ json: { httpStatus: statusCode, body } }];\n}\n\nfunction errorEnvelope(requestId, code, message, details) {\n  return {\n    request_id: requestId || null,\n    status: 'error',\n    correlation_id: executionId,\n    data: null,\n    error: { code, message, details: details || {} }\n  };\n}\n\nfunction okEnvelope(requestId, data) {\n  return {\n    request_id: requestId,\n    status: 'ok',\n    correlation_id: executionId,\n    data,\n    error: null\n  };\n}\n\nconst notionToken = $env.NOTION_API_KEY;\nif (!notionToken) {\n  return respond(500, errorEnvelope(null, 'config_error', 'NOTION_API_KEY is not set', {}));\n}\n\nconst baseUrl = 'https://api.notion.com/v1';\nconst notionHeaders = {\n  Authorization: `Bearer ${notionToken}`,\n  'Notion-Version': '2022-06-28',\n  'Content-Type': 'application/json'\n};\n\nconst request = async (method, urlPath, bodyData) => {\n  const options = {\n    method,\n    url: `${baseUrl}${urlPath}`,\n    headers: notionHeaders,\n    json: true\n  };\n  if (bodyData) options.body = bodyData;\n  return this.helpers.httpRequest(options);\n};\n\nconst titleText = (text) => ({ title: [{ text: { content: text } }] });\nconst richText = (text) => ({ rich_text: [{ text: { content: text } }] });\n\nconst getTitleFromPage = (page) => {\n  if (!page || !page.properties) return '';\n  const titleKey = Object.keys(page.properties).find((key) => page.properties[key].type === 'title');\n  if (!titleKey) return '';\n  const titleArray = page.properties[titleKey].title || [];\n  return titleArray.map((t) => t.plain_text).join('');\n};\n\nconst getTitleFromDatabase = (db) => {\n  if (!db || !Array.isArray(db.title)) return '';\n  return db.title.map((t) => t.plain_text).join('');\n};\n\nconst queryDatabase = async (dbId, filter) => {\n  return request('POST', `/databases/${dbId}/query`, { filter, page_size: 1 });\n};\n\nconst getPropertyText = (page, propName) => {\n  const prop = page.properties[propName];\n  if (!prop) return '';\n  if (prop.type === 'rich_text') return (prop.rich_text || []).map((t) => t.plain_text).join('');\n  if (prop.type === 'title') return (prop.title || []).map((t) => t.plain_text).join('');\n  return '';\n};\n\nconst findDatabaseByTitle = async (title) => {\n  const res = await request('POST', '/search', {\n    query: title,\n    page_size: 10,\n    filter: { property: 'object', value: 'database' }\n  });\n  return (res.results || []).find((db) => getTitleFromDatabase(db) === title) || null;\n};\n\nconst findRegistryDbId = async () => {\n  const registryDb = await findDatabaseByTitle('OS Registry');\n  return registryDb ? registryDb.id : null;\n};\n\nconst findRegistryValue = async (registryDbId, key) => {\n  const res = await queryDatabase(registryDbId, {\n    property: 'Key',\n    title: { equals: key }\n  });\n  const page = (res.results || [])[0];\n  if (!page) return null;\n  return getPropertyText(page, 'Value');\n};\n\nconst resolveLedgerDbId = async (registryDbId) => {\n  if (!registryDbId) return null;\n  const ledgerId = await findRegistryValue(registryDbId, 'ledger_db_id');\n  if (ledgerId) return ledgerId;\n  const ledgerDb = await findDatabaseByTitle('Request Ledger');\n  return ledgerDb ? ledgerDb.id : null;\n};\n\nconst resolveDatabaseId = async (registryDbId, databaseKey) => {\n  if (!registryDbId) return null;\n  if (databaseKey === 'registry') return registryDbId;\n  if (databaseKey === 'request_ledger') return await resolveLedgerDbId(registryDbId);\n  const key = `${databaseKey}_db_id`;\n  const dbId = await findRegistryValue(registryDbId, key);\n  return dbId || null;\n};\n\nconst findLedgerEntry = async (ledgerDbId, idempotencyKey) => {\n  const res = await queryDatabase(ledgerDbId, {\n    property: 'Idempotency Key',\n    title: { equals: idempotencyKey }\n  });\n  return (res.results || [])[0] || null;\n};\n\nconst createLedgerEntry = async (ledgerDbId, data) => {\n  const properties = {\n    'Idempotency Key': titleText(data.idempotencyKey),\n    'Request ID': richText(data.requestId),\n    'Endpoint': richText(data.endpoint),\n    'Status': { select: { name: data.status } },\n    'Result Object ID': richText(data.resultObjectId || ''),\n    'Timestamp': { date: { start: data.timestamp } },\n    'Raw Request': richText(data.rawRequest || '')\n  };\n  return request('POST', '/pages', {\n    parent: { database_id: ledgerDbId },\n    properties\n  });\n};\n\nconst getPage = async (pageId) => request('GET', `/pages/${pageId}`);\n\n\nconst headers = $json.headers || {};\nconst authHeader = (headers.authorization || headers.Authorization || '').trim();\nconst bearerToken = $env.BOOTSTRAP_BEARER_TOKEN || $env.API_BEARER_TOKEN || '';\n\nif (!bearerToken) {\n  return respond(500, errorEnvelope(null, 'config_error', 'No bearer token configured', {}));\n}\n\nconst expectedAuth = `Bearer ${bearerToken}`;\n\nif (authHeader !== expectedAuth) {\n  return respond(401, errorEnvelope(null, 'unauthorized', 'Invalid or missing Authorization header', {}));\n}\n\nconst body = $json.body;\nif (!body || typeof body !== 'object') {\n  return respond(400, errorEnvelope(null, 'invalid_request', 'Request body must be a JSON object', {}));\n}\n\nconst { request_id, actor, payload } = body;\nif (typeof request_id !== 'string' || typeof actor !== 'string' || typeof payload !== 'object' || payload === null) {\n  return respond(400, errorEnvelope(request_id, 'invalid_request', 'Missing or invalid request envelope fields', {}));\n}\n\nconst { database_key, limit, filter } = payload;\nif (typeof database_key !== 'string' || !database_key.trim()) {\n  return respond(400, errorEnvelope(request_id, 'invalid_request', 'payload.database_key is required', {}));\n}\n\nconst pageSize = typeof limit === 'number' && limit > 0 ? Math.min(limit, 100) : 25;\n\nconst buildFilter = () => {\n  if (!filter) return null;\n  if (typeof filter !== 'object') return null;\n  const { property, equals, type } = filter;\n  if (typeof property !== 'string' || typeof equals !== 'string' || typeof type !== 'string') return null;\n\n  if (type === 'title') return { property, title: { equals } };\n  if (type === 'rich_text') return { property, rich_text: { equals } };\n  if (type === 'select') return { property, select: { equals } };\n  if (type === 'status') return { property, status: { equals } };\n  return null;\n};\n\nconst normalizeProperty = (prop) => {\n  if (!prop) return null;\n  if (prop.type === 'title') return (prop.title || []).map((t) => t.plain_text).join('');\n  if (prop.type === 'rich_text') return (prop.rich_text || []).map((t) => t.plain_text).join('');\n  if (prop.type === 'select') return prop.select ? prop.select.name : null;\n  if (prop.type === 'multi_select') return (prop.multi_select || []).map((s) => s.name);\n  if (prop.type === 'date') return prop.date ? prop.date.start : null;\n  if (prop.type === 'number') return prop.number;\n  if (prop.type === 'checkbox') return prop.checkbox;\n  if (prop.type === 'url') return prop.url;\n  return null;\n};\n\ntry {\n  const registryDbId = await findRegistryDbId();\n  if (!registryDbId) {\n    return respond(500, errorEnvelope(request_id, 'registry_not_found', 'OS Registry database not found', {}));\n  }\n\n  const databaseId = await resolveDatabaseId(registryDbId, database_key);\n  if (!databaseId) {\n    return respond(400, errorEnvelope(request_id, 'invalid_request', 'Unknown database_key', { database_key }));\n  }\n\n  const notionFilter = buildFilter();\n  if (filter && !notionFilter) {\n    return respond(400, errorEnvelope(request_id, 'invalid_request', 'Unsupported filter format', {}));\n  }\n\n  const queryBody = { page_size: pageSize };\n  if (notionFilter) queryBody.filter = notionFilter;\n\n  const res = await request('POST', `/databases/${databaseId}/query`, queryBody);\n  const rows = (res.results || []).map((row) => {\n    const props = {};\n    Object.keys(row.properties || {}).forEach((key) => {\n      props[key] = normalizeProperty(row.properties[key]);\n    });\n    return {\n      id: row.id,\n      url: row.url,\n      properties: props\n    };\n  });\n\n  return respond(200, okEnvelope(request_id, {\n    database_key,\n    database_id: databaseId,\n    results: rows\n  }));\n} catch (error) {\n  const message = error && error.message ? error.message : 'Sample query failed';\n  return respond(500, errorEnvelope(request_id, 'sample_failed', message, { stack: error && error.stack }));\n}\n"
      },
      "id": "07310dce-e280-4743-8ce5-235b582ce502",
      "name": "Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        40,
        0
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json.body}}",
        "options": {
          "responseCode": "={{$json.httpStatus}}"
        }
      },
      "id": "fd6f5e96-e138-49f1-8635-5d0317288b22",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        300,
        0
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handler": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "b9aa3ab6-279f-4239-81b6-1c264896d321",
  "id": "4595a49a-9725-4af4-9c8c-5946dafd9a22",
  "tags": []
}