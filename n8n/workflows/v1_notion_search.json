{
  "name": "v1_notion_search",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "v1/notion/search",
        "responseMode": "responseNode"
      },
      "id": "4d26f50b-5e6a-4ccf-82b8-21d2c38b7e9b",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -200,
        0
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "\nconst executionId = this.getExecutionId ? this.getExecutionId() : Date.now().toString();\n\nfunction respond(statusCode, body) {\n  return [{ json: { httpStatus: statusCode, body } }];\n}\n\nfunction errorEnvelope(requestId, code, message, details) {\n  return {\n    request_id: requestId || null,\n    status: 'error',\n    correlation_id: executionId,\n    data: null,\n    error: { code, message, details: details || {} }\n  };\n}\n\nfunction okEnvelope(requestId, data) {\n  return {\n    request_id: requestId,\n    status: 'ok',\n    correlation_id: executionId,\n    data,\n    error: null\n  };\n}\n\nconst notionToken = $env.NOTION_API_KEY;\nif (!notionToken) {\n  return respond(500, errorEnvelope(null, 'config_error', 'NOTION_API_KEY is not set', {}));\n}\n\nconst baseUrl = 'https://api.notion.com/v1';\nconst notionHeaders = {\n  Authorization: `Bearer ${notionToken}`,\n  'Notion-Version': '2022-06-28',\n  'Content-Type': 'application/json'\n};\n\nconst request = async (method, urlPath, bodyData) => {\n  const options = {\n    method,\n    url: `${baseUrl}${urlPath}`,\n    headers: notionHeaders,\n    json: true\n  };\n  if (bodyData) options.body = bodyData;\n  return this.helpers.httpRequest(options);\n};\n\nconst titleText = (text) => ({ title: [{ text: { content: text } }] });\nconst richText = (text) => ({ rich_text: [{ text: { content: text } }] });\n\nconst getTitleFromPage = (page) => {\n  if (!page || !page.properties) return '';\n  const titleKey = Object.keys(page.properties).find((key) => page.properties[key].type === 'title');\n  if (!titleKey) return '';\n  const titleArray = page.properties[titleKey].title || [];\n  return titleArray.map((t) => t.plain_text).join('');\n};\n\nconst getTitleFromDatabase = (db) => {\n  if (!db || !Array.isArray(db.title)) return '';\n  return db.title.map((t) => t.plain_text).join('');\n};\n\nconst queryDatabase = async (dbId, filter) => {\n  return request('POST', `/databases/${dbId}/query`, { filter, page_size: 1 });\n};\n\nconst getPropertyText = (page, propName) => {\n  const prop = page.properties[propName];\n  if (!prop) return '';\n  if (prop.type === 'rich_text') return (prop.rich_text || []).map((t) => t.plain_text).join('');\n  if (prop.type === 'title') return (prop.title || []).map((t) => t.plain_text).join('');\n  return '';\n};\n\nconst findDatabaseByTitle = async (title) => {\n  const res = await request('POST', '/search', {\n    query: title,\n    page_size: 10,\n    filter: { property: 'object', value: 'database' }\n  });\n  return (res.results || []).find((db) => getTitleFromDatabase(db) === title) || null;\n};\n\nconst findRegistryDbId = async () => {\n  const registryDb = await findDatabaseByTitle('OS Registry');\n  return registryDb ? registryDb.id : null;\n};\n\nconst findRegistryValue = async (registryDbId, key) => {\n  const res = await queryDatabase(registryDbId, {\n    property: 'Key',\n    title: { equals: key }\n  });\n  const page = (res.results || [])[0];\n  if (!page) return null;\n  return getPropertyText(page, 'Value');\n};\n\nconst resolveLedgerDbId = async (registryDbId) => {\n  if (!registryDbId) return null;\n  const ledgerId = await findRegistryValue(registryDbId, 'ledger_db_id');\n  if (ledgerId) return ledgerId;\n  const ledgerDb = await findDatabaseByTitle('Request Ledger');\n  return ledgerDb ? ledgerDb.id : null;\n};\n\nconst resolveDatabaseId = async (registryDbId, databaseKey) => {\n  if (!registryDbId) return null;\n  if (databaseKey === 'registry') return registryDbId;\n  if (databaseKey === 'request_ledger') return await resolveLedgerDbId(registryDbId);\n  const key = `${databaseKey}_db_id`;\n  const dbId = await findRegistryValue(registryDbId, key);\n  return dbId || null;\n};\n\nconst findLedgerEntry = async (ledgerDbId, idempotencyKey) => {\n  const res = await queryDatabase(ledgerDbId, {\n    property: 'Idempotency Key',\n    title: { equals: idempotencyKey }\n  });\n  return (res.results || [])[0] || null;\n};\n\nconst createLedgerEntry = async (ledgerDbId, data) => {\n  const properties = {\n    'Idempotency Key': titleText(data.idempotencyKey),\n    'Request ID': richText(data.requestId),\n    'Endpoint': richText(data.endpoint),\n    'Status': { select: { name: data.status } },\n    'Result Object ID': richText(data.resultObjectId || ''),\n    'Timestamp': { date: { start: data.timestamp } },\n    'Raw Request': richText(data.rawRequest || '')\n  };\n  return request('POST', '/pages', {\n    parent: { database_id: ledgerDbId },\n    properties\n  });\n};\n\nconst getPage = async (pageId) => request('GET', `/pages/${pageId}`);\n\n\nconst headers = $json.headers || {};\nconst authHeader = (headers.authorization || headers.Authorization || '').trim();\nconst bearerToken = $env.BOOTSTRAP_BEARER_TOKEN || $env.API_BEARER_TOKEN || '';\n\nif (!bearerToken) {\n  return respond(500, errorEnvelope(null, 'config_error', 'No bearer token configured', {}));\n}\n\nconst expectedAuth = `Bearer ${bearerToken}`;\n\nif (authHeader !== expectedAuth) {\n  return respond(401, errorEnvelope(null, 'unauthorized', 'Invalid or missing Authorization header', {}));\n}\n\nconst body = $json.body;\nif (!body || typeof body !== 'object') {\n  return respond(400, errorEnvelope(null, 'invalid_request', 'Request body must be a JSON object', {}));\n}\n\nconst { request_id, actor, payload } = body;\nif (typeof request_id !== 'string' || typeof actor !== 'string' || typeof payload !== 'object' || payload === null) {\n  return respond(400, errorEnvelope(request_id, 'invalid_request', 'Missing or invalid request envelope fields', {}));\n}\n\nconst query = payload.query;\nconst limit = payload.limit;\nconst types = Array.isArray(payload.types) ? payload.types : ['page', 'database'];\n\nif (typeof query !== 'string') {\n  return respond(400, errorEnvelope(request_id, 'invalid_request', 'payload.query must be a string', {}));\n}\n\nconst maxResults = typeof limit === 'number' && limit > 0 ? Math.min(limit, 100) : 10;\nconst typeSet = new Set(types);\n\nconst searchType = async (type) => {\n  const res = await request('POST', '/search', {\n    query,\n    page_size: maxResults,\n    filter: { property: 'object', value: type }\n  });\n  return res.results || [];\n};\n\ntry {\n  let results = [];\n  if (typeSet.has('page')) {\n    results = results.concat(await searchType('page'));\n  }\n  if (typeSet.has('database')) {\n    results = results.concat(await searchType('database'));\n  }\n\n  results = results.slice(0, maxResults);\n\n  const normalized = results.map((item) => {\n    const objectType = item.object;\n    const title = objectType === 'database' ? getTitleFromDatabase(item) : getTitleFromPage(item);\n    return {\n      id: item.id,\n      object_type: objectType,\n      title,\n      url: item.url,\n      last_edited_time: item.last_edited_time\n    };\n  });\n\n  return respond(200, okEnvelope(request_id, { results: normalized }));\n} catch (error) {\n  const message = error && error.message ? error.message : 'Search failed';\n  return respond(500, errorEnvelope(request_id, 'search_failed', message, { stack: error && error.stack }));\n}\n"
      },
      "id": "bae504f0-b102-4a1a-b0bb-4d32fe4584dd",
      "name": "Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        40,
        0
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json.body}}",
        "options": {
          "responseCode": "={{$json.httpStatus}}"
        }
      },
      "id": "0873ab57-0944-4d9f-b18c-e261300b49fc",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        300,
        0
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handler": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "7b83ba6b-0831-4b8f-8d91-7cde7d9a3fcc",
  "id": "91fc2b4a-1810-414e-a80f-a182c31666b4",
  "tags": []
}